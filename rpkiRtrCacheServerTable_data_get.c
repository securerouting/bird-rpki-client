/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "rpkiRtrCacheServerTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement rpkiRtrCacheServerTable get routines.
 * TODO:240:M: Implement rpkiRtrCacheServerTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table rpkiRtrCacheServerTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * RPKI-RTR-MIB::rpkiRtrCacheServerTable is subid 2 of rpkiRtrObjects.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.218.1.2, length: 9
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement rpkiRtrCacheServerTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param rpkiRtrCacheServerRemoteAddressType_val
 * @param rpkiRtrCacheServerRemoteAddress_ptr
 * @param rpkiRtrCacheServerRemoteAddress_ptr_len
 * @param rpkiRtrCacheServerRemotePort_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
rpkiRtrCacheServerTable_indexes_set_tbl_idx
    (rpkiRtrCacheServerTable_mib_index * tbl_idx,
     u_long rpkiRtrCacheServerRemoteAddressType_val,
     char *rpkiRtrCacheServerRemoteAddress_val_ptr,
     size_t rpkiRtrCacheServerRemoteAddress_val_ptr_len,
     u_long rpkiRtrCacheServerRemotePort_val)
{
    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerTable_indexes_set_tbl_idx", "called\n"));

    /*
     * rpkiRtrCacheServerRemoteAddressType(1)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    tbl_idx->rpkiRtrCacheServerRemoteAddressType =
        rpkiRtrCacheServerRemoteAddressType_val;

    /*
     * rpkiRtrCacheServerRemoteAddress(2)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    tbl_idx->rpkiRtrCacheServerRemoteAddress_len = sizeof(tbl_idx->rpkiRtrCacheServerRemoteAddress) / sizeof(tbl_idx->rpkiRtrCacheServerRemoteAddress[0]);      /* max length */
    /*
     * make sure there is enough space for rpkiRtrCacheServerRemoteAddress data
     */
    if ((NULL == tbl_idx->rpkiRtrCacheServerRemoteAddress) ||
        (tbl_idx->rpkiRtrCacheServerRemoteAddress_len <
         (rpkiRtrCacheServerRemoteAddress_val_ptr_len))) {
        snmp_log(LOG_ERR,
                 "not enough space for value (rpkiRtrCacheServerRemoteAddress_val_ptr)\n");
        return MFD_ERROR;
    }
    tbl_idx->rpkiRtrCacheServerRemoteAddress_len =
        rpkiRtrCacheServerRemoteAddress_val_ptr_len;
    memcpy(tbl_idx->rpkiRtrCacheServerRemoteAddress,
           rpkiRtrCacheServerRemoteAddress_val_ptr,
           rpkiRtrCacheServerRemoteAddress_val_ptr_len *
           sizeof(rpkiRtrCacheServerRemoteAddress_val_ptr[0]));

    /*
     * rpkiRtrCacheServerRemotePort(3)/InetPortNumber/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/H 
     */
    tbl_idx->rpkiRtrCacheServerRemotePort =
        rpkiRtrCacheServerRemotePort_val;


    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
rpkiRtrCacheServerTable_indexes_set(rpkiRtrCacheServerTable_rowreq_ctx *
                                    rowreq_ctx,
                                    u_long
                                    rpkiRtrCacheServerRemoteAddressType_val,
                                    char
                                    *rpkiRtrCacheServerRemoteAddress_val_ptr,
                                    size_t
                                    rpkiRtrCacheServerRemoteAddress_val_ptr_len,
                                    u_long
                                    rpkiRtrCacheServerRemotePort_val)
{
    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        rpkiRtrCacheServerTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                    rpkiRtrCacheServerRemoteAddressType_val,
                                                    rpkiRtrCacheServerRemoteAddress_val_ptr,
                                                    rpkiRtrCacheServerRemoteAddress_val_ptr_len,
                                                    rpkiRtrCacheServerRemotePort_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != rpkiRtrCacheServerTable_index_to_oid(&rowreq_ctx->oid_idx,
                                                  &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerTable_indexes_set */


/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerLocalAddressType
 * rpkiRtrCacheServerLocalAddressType is subid 4 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.4
 * Description:
The network address type of the connection
                 to this RPKI cache server.

                 Note: Only IPv4, IPv6 and DNS support are required
                 for RFCxxxx read only compliance.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 4/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * Its syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerLocalAddressType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerLocalAddressType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerLocalAddressType_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       rpkiRtrCacheServerLocalAddressType_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerLocalAddressType_val_ptr);

    (*rpkiRtrCacheServerLocalAddressType_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerLocalAddressType;
    /*
     * the rpkiRtrCacheServerTable_rowreq_ctx->data pointer should be
     * pointer to the data you supplied during the data lookup, so you
     * should know how to determine the InetAddressType from this
     * pointer.
     */

    (*rpkiRtrCacheServerLocalAddressType_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerLocalAddressType;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerLocalAddressType_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerLocalAddress
 * rpkiRtrCacheServerLocalAddress is subid 5 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.5
 * Description:
The local network address for this connection 
                 to this RPKI cache server.

                 The format of the address is defined by the
                 value of the corresponding instance of
                 rpkiRtrCacheServerLocalAddressType.

                 This object matches the address type used within
                 the local router configuration.  If the address is
                 of type dns (fqdn), then the router will resolve it
                 at the time it connects to the cache server.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerLocalAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerLocalAddress_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rpkiRtrCacheServerLocalAddress_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rpkiRtrCacheServerLocalAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rpkiRtrCacheServerLocalAddress_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rpkiRtrCacheServerLocalAddress_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rpkiRtrCacheServerLocalAddress_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                   rowreq_ctx,
                                   char
                                   **rpkiRtrCacheServerLocalAddress_val_ptr_ptr,
                                   size_t
                                   *rpkiRtrCacheServerLocalAddress_val_ptr_len_ptr)
{
    /*
     * TODO:231:M: |-> copy rpkiRtrCacheServerLocalAddress data.
     * TODO:231:M: |   |-> get address type from your context pointer.
     */
    int     addressType = rowreq_ctx->data.rpkiRtrCacheServerLocalAddressType;
    size_t  actual_size = 0;

    switch (addressType) {
    case INETADDRESSTYPE_UNKNOWN:
        /*
         * An unknown address type. This value MUST  be used if the value
         * of the InetAddress object is a zero-length string. It may also be
         * used to indicate an IP address which is not in one of the formats
         * defined below.
         */
        actual_size = rowreq_ctx->data.rpkiRtrCacheServerLocalAddress_len;
        break;

    case INETADDRESSTYPE_IPV4:
        /*
         * Represents an IPv4 network address:
         *      octets   contents         encoding
         *       1-4     IPv4 address     network-byte order
         */
        actual_size = 4;
        break;

    case INETADDRESSTYPE_IPV6:
        /*
         * Represents an IPv6 network address:
         *
         *      octets   contents         encoding
         *       1-16    IPv6 address     network-byte order
         */
        actual_size = 16;
        break;

    case INETADDRESSTYPE_IPV4Z:
        /*
         * Represents a non-global IPv4 network address together
         *    with its zone index:
         *
         *      octets   contents         encoding
         *       1-4     IPv4 address     network-byte order
         *       5-8     zone index       network-byte order
         */
        actual_size = 8;
        break;

    case INETADDRESSTYPE_IPV6Z:
        /*
         * Represents a non-global IPv6 network address together
         *    with its zone index:
         *
         *      octets   contents         encoding
         *       1-16    IPv6 address     network-byte order
         *      17-20    zone index       network-byte order
         */
        actual_size = 20;
        break;

    case INETADDRESSTYPE_DNS:
        /*
         * Represents a DNS domain name. The name SHOULD be fully
         *    qualified whenever possible.
         */
        actual_size = rowreq_ctx->data.rpkiRtrCacheServerLocalAddress_len;
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown InetAddressType %d for rpkiRtrCacheServerLocalAddress\n",
                 addressType);
        return SNMP_ERR_GENERR;
    }

    if (actual_size > (*rpkiRtrCacheServerLocalAddress_val_ptr_len_ptr)) {
        snmp_log(LOG_ERR,
                 "actual size %d too big for rpkiRtrCacheServerLocalAddress\n",
                 addressType);
        return SNMP_ERR_GENERR;
    }

    memcpy((*rpkiRtrCacheServerLocalAddress_val_ptr_ptr),
           rowreq_ctx->data.rpkiRtrCacheServerLocalAddress, actual_size);
    (*rpkiRtrCacheServerLocalAddress_val_ptr_len_ptr) = actual_size;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerLocalAddress_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerLocalPort
 * rpkiRtrCacheServerLocalPort is subid 6 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.6
 * Description:
The local port number for this connection
                 to this RPKI cache server.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: d
 *
 * Ranges:  1 - 65535;
 *
 * Its syntax is InetPortNumber (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerLocalPort data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerLocalPort_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerLocalPort_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long *
                                rpkiRtrCacheServerLocalPort_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerLocalPort_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerLocalPort_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rpkiRtrCacheServerLocalPort data.
     * copy (* rpkiRtrCacheServerLocalPort_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerLocalPort_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerLocalPort;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerLocalPort_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerPreference
 * rpkiRtrCacheServerPreference is subid 7 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.7
 * Description:
The routers' preference for this RPKI cache server.

                 A lower value means more preferred. If two entries
                 have the same preference, then the order is
                 arbitrary.

                 In two cases the maximum value for an Unsigned32
                 object should be returned for this object:
                 - If no order is specified in the RPKI Router
                   configuration.
                 - If a preference value is configured that is
                   larger than the max value for an Unsigned32
                   object.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *   defval: 4294967295
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerPreference data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerPreference_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerPreference_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                 rowreq_ctx,
                                 u_long *
                                 rpkiRtrCacheServerPreference_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerPreference_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerPreference_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rpkiRtrCacheServerPreference data.
     * copy (* rpkiRtrCacheServerPreference_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerPreference_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerPreference;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerPreference_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerConnectionType
 * rpkiRtrCacheServerConnectionType is subid 8 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.8
 * Description:
The connection type or transport security suite
                 in use for this RPKI cache server.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  ssh(1), tls(2), tcpMD5(3), tcpAO(4), tcp(5), ipsec(6), other(7)
 *
 * Its syntax is RpkiRtrConnectionType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerConnectionType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerConnectionType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerConnectionType_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     rpkiRtrCacheServerConnectionType_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerConnectionType_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerConnectionType_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rpkiRtrCacheServerConnectionType data.
     * copy (* rpkiRtrCacheServerConnectionType_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerConnectionType_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerConnectionType;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerConnectionType_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerConnectionStatus
 * rpkiRtrCacheServerConnectionStatus is subid 9 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.9
 * Description:
The connection status for this entry
                 (connection to this RPKI cache server).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  up(1), down(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerConnectionStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerConnectionStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerConnectionStatus_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       rpkiRtrCacheServerConnectionStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerConnectionStatus_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerConnectionStatus_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    (*rpkiRtrCacheServerConnectionStatus_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerConnectionStatus;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerConnectionStatus_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerDescription
 * rpkiRtrCacheServerDescription is subid 10 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.10
 * Description:
Free form description/information for this
                 connection to this RPKI cache server.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 1024a
 *
 * Ranges:  0 - 1024;
 *
 * Its syntax is LongUtf8String (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 1024)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerDescription data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerDescription_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rpkiRtrCacheServerDescription_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rpkiRtrCacheServerDescription.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rpkiRtrCacheServerDescription_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rpkiRtrCacheServerDescription_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rpkiRtrCacheServerDescription_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                  rowreq_ctx,
                                  char
                                  **rpkiRtrCacheServerDescription_val_ptr_ptr,
                                  size_t
                                  *rpkiRtrCacheServerDescription_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rpkiRtrCacheServerDescription_val_ptr_ptr)
                   && (NULL !=
                       *rpkiRtrCacheServerDescription_val_ptr_ptr));
    netsnmp_assert(NULL != rpkiRtrCacheServerDescription_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerDescription_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerDescription data.  copy (*
     * rpkiRtrCacheServerDescription_val_ptr_ptr ) data and (*
     * rpkiRtrCacheServerDescription_val_ptr_len_ptr ) from
     * rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rpkiRtrCacheServerDescription data
     */
    if ((NULL == (*rpkiRtrCacheServerDescription_val_ptr_ptr)) ||
        ((*rpkiRtrCacheServerDescription_val_ptr_len_ptr) <
         (rowreq_ctx->data.rpkiRtrCacheServerDescription_len *
          sizeof(rowreq_ctx->data.rpkiRtrCacheServerDescription[0])))) {
        /*
         * allocate space for rpkiRtrCacheServerDescription data
         */
        (*rpkiRtrCacheServerDescription_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rpkiRtrCacheServerDescription_len *
                   sizeof(rowreq_ctx->data.
                          rpkiRtrCacheServerDescription[0]));
        if (NULL == (*rpkiRtrCacheServerDescription_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rpkiRtrCacheServerDescription)\n");
            return MFD_ERROR;
        }
    }
    (*rpkiRtrCacheServerDescription_val_ptr_len_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerDescription_len *
        sizeof(rowreq_ctx->data.rpkiRtrCacheServerDescription[0]);
    memcpy( (*rpkiRtrCacheServerDescription_val_ptr_ptr),
	    rowreq_ctx->data.rpkiRtrCacheServerDescription,
	    (rowreq_ctx->data.rpkiRtrCacheServerDescription_len *
	     sizeof(rowreq_ctx->data.rpkiRtrCacheServerDescription[0])) );

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerDescription_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerMsgsReceived
 * rpkiRtrCacheServerMsgsReceived is subid 11 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.11
 * Description:
Number of messages received from this
                 RPKI cache server via this connection.

                 Discontinuities are indicated by the value
                 of rpkiRtrDiscontinuityTimer.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerMsgsReceived data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerMsgsReceived_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerMsgsReceived_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   rpkiRtrCacheServerMsgsReceived_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerMsgsReceived_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerMsgsReceived_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    (*rpkiRtrCacheServerMsgsReceived_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerMsgsReceived;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerMsgsReceived_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerMsgsSent
 * rpkiRtrCacheServerMsgsSent is subid 12 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.12
 * Description:
Number of messages sent to this
                 RPKI cache server via this connection.

                 Discontinuities are indicated by the value
                 of rpkiRtrDiscontinuityTimer.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerMsgsSent data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerMsgsSent_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerMsgsSent_get(rpkiRtrCacheServerTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long * rpkiRtrCacheServerMsgsSent_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerMsgsSent_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerMsgsSent_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    (*rpkiRtrCacheServerMsgsSent_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerMsgsSent;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerMsgsSent_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerV4ActiveRecords
 * rpkiRtrCacheServerV4ActiveRecords is subid 13 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.13
 * Description:
Number of active IPv4 records received from
                 this RPKI cache server via this connection.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerV4ActiveRecords data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerV4ActiveRecords_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerV4ActiveRecords_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      rpkiRtrCacheServerV4ActiveRecords_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerV4ActiveRecords_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerV4ActiveRecords_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    (*rpkiRtrCacheServerV4ActiveRecords_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerV4ActiveRecords;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerV4ActiveRecords_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerV4Announcements
 * rpkiRtrCacheServerV4Announcements is subid 14 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.14
 * Description:
The number of IPv4 records announced by the 
                 RPKI cache Server via this connection.

                 Discontinuities are indicated by the value
                 of rpkiRtrDiscontinuityTimer.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerV4Announcements data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerV4Announcements_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerV4Announcements_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      rpkiRtrCacheServerV4Announcements_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerV4Announcements_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerV4Announcements_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    (*rpkiRtrCacheServerV4Announcements_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerV4Announcements;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerV4Announcements_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerV4Withdrawals
 * rpkiRtrCacheServerV4Withdrawals is subid 15 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.15
 * Description:
The number of IPv4 records withdrawn by the
                 RPKI cache Server via this connection.

                 Discontinuities are indicated by the value
                 of rpkiRtrDiscontinuityTimer.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerV4Withdrawals data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerV4Withdrawals_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerV4Withdrawals_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                    rowreq_ctx,
                                    u_long *
                                    rpkiRtrCacheServerV4Withdrawals_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerV4Withdrawals_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerV4Withdrawals_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerV4Withdrawals data.  copy (*
     * rpkiRtrCacheServerV4Withdrawals_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerV4Withdrawals_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerV4Withdrawals;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerV4Withdrawals_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerV6ActiveRecords
 * rpkiRtrCacheServerV6ActiveRecords is subid 16 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.16
 * Description:
Number of active IPv6 records received from
                 this RPKI cache server via this connection.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerV6ActiveRecords data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerV6ActiveRecords_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerV6ActiveRecords_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      rpkiRtrCacheServerV6ActiveRecords_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerV6ActiveRecords_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerV6ActiveRecords_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerV6ActiveRecords data.  copy (*
     * rpkiRtrCacheServerV6ActiveRecords_val_ptr ) from
     * rowreq_ctx->data
     */
    (*rpkiRtrCacheServerV6ActiveRecords_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerV6ActiveRecords;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerV6ActiveRecords_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerV6Announcements
 * rpkiRtrCacheServerV6Announcements is subid 17 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.17
 * Description:
The number of IPv6 records announced by the 
                 RPKI cache Server via this connection.

                 Discontinuities are indicated by the value
                 of rpkiRtrDiscontinuityTimer.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerV6Announcements data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerV6Announcements_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerV6Announcements_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      rpkiRtrCacheServerV6Announcements_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerV6Announcements_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerV6Announcements_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerV6Announcements data.  copy (*
     * rpkiRtrCacheServerV6Announcements_val_ptr ) from
     * rowreq_ctx->data
     */
    (*rpkiRtrCacheServerV6Announcements_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerV6Announcements;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerV6Announcements_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerV6Withdrawals
 * rpkiRtrCacheServerV6Withdrawals is subid 18 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.18
 * Description:
The number of IPv6 records withdrawn by the
                 RPKI cache Server via this connection.

                 Discontinuities are indicated by the value
                 of rpkiRtrDiscontinuityTimer.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerV6Withdrawals data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerV6Withdrawals_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerV6Withdrawals_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                    rowreq_ctx,
                                    u_long *
                                    rpkiRtrCacheServerV6Withdrawals_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerV6Withdrawals_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerV6Withdrawals_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerV6Withdrawals data.  copy (*
     * rpkiRtrCacheServerV6Withdrawals_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerV6Withdrawals_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerV6Withdrawals;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerV6Withdrawals_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerLatestSerial
 * rpkiRtrCacheServerLatestSerial is subid 19 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.19
 * Description:
The latest serial number of data received from
                 this RPKI server on this connection.

                 Note: this value wraps back to zero when it
                 reaches its maximum value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerLatestSerial data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerLatestSerial_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerLatestSerial_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   rpkiRtrCacheServerLatestSerial_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerLatestSerial_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerLatestSerial_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerLatestSerial data.  copy (*
     * rpkiRtrCacheServerLatestSerial_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerLatestSerial_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerLatestSerial;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerLatestSerial_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerSessionID
 * rpkiRtrCacheServerSessionID is subid 20 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.20
 * Description:
The Session ID associated with the RPKI cache
                 server at the other end of this connection.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerSessionID data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerSessionID_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerSessionID_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long *
                                rpkiRtrCacheServerSessionID_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerSessionID_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerSessionID_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerSessionID data.  copy (*
     * rpkiRtrCacheServerSessionID_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerSessionID_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerSessionID;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerSessionID_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerRefreshTimer
 * rpkiRtrCacheServerRefreshTimer is subid 21 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.21
 * Description:
The number of seconds configured for the refresh
                 timer for this connection to this RPKI cache
                 server.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  60 - 7200;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerRefreshTimer data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerRefreshTimer_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerRefreshTimer_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   rpkiRtrCacheServerRefreshTimer_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerRefreshTimer_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerRefreshTimer_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerRefreshTimer data.  copy (*
     * rpkiRtrCacheServerRefreshTimer_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerRefreshTimer_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerRefreshTimer;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerRefreshTimer_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerTimeToRefresh
 * rpkiRtrCacheServerTimeToRefresh is subid 22 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.22
 * Description:
The number of seconds remaining before a new
                 refresh is performed via a Serial Query to 
                 this cache server over this connection.

                 A negative value means that the refresh time has
                 passed this many seconds and the refresh has not
                 yet been completed. It will stop decrementing at
                 the maximum negative value.

                 Upon a completed refresh (i.e. a successful
                 and complete response to a Serial Query) the
                 value of this attribute will be re-initialized
                 with the value of the corresponding 
                 rpkiRtrCacheServerRefreshTimer attribute.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerTimeToRefresh data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerTimeToRefresh_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerTimeToRefresh_get(rpkiRtrCacheServerTable_rowreq_ctx *
                                    rowreq_ctx,
                                    long
                                    *rpkiRtrCacheServerTimeToRefresh_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerTimeToRefresh_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerTimeToRefresh_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerTimeToRefresh data.  copy (*
     * rpkiRtrCacheServerTimeToRefresh_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerTimeToRefresh_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerTimeToRefresh;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerTimeToRefresh_get */

/*---------------------------------------------------------------------
 * RPKI-RTR-MIB::rpkiRtrCacheServerTableEntry.rpkiRtrCacheServerId
 * rpkiRtrCacheServerId is subid 23 of rpkiRtrCacheServerTableEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.218.1.2.1.23
 * Description:
The unique ID for this connection.

                 An implementation must make sure this ID is unique
                 within this table. It is this ID that can be used
                 to find entries in the rpkiRtrPrefixOriginTable
                 that were created by announcements received on
                 this connection from this cache server.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - -1;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rpkiRtrCacheServerId data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rpkiRtrCacheServerId_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rpkiRtrCacheServerId_get(rpkiRtrCacheServerTable_rowreq_ctx * rowreq_ctx,
                         u_long * rpkiRtrCacheServerId_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rpkiRtrCacheServerId_val_ptr);


    DEBUGMSGTL(("verbose:rpkiRtrCacheServerTable:rpkiRtrCacheServerId_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the
     * rpkiRtrCacheServerId data.  copy (*
     * rpkiRtrCacheServerId_val_ptr ) from rowreq_ctx->data
     */
    (*rpkiRtrCacheServerId_val_ptr) =
        rowreq_ctx->data.rpkiRtrCacheServerId;

    return MFD_SUCCESS;
}                               /* rpkiRtrCacheServerId_get */



/** @} */
